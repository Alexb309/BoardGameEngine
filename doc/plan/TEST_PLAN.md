
[//]: # Comment with directions from webpage (leave blank lines above and below for proper commenting syntax): Describe at least two specific strategies your team discussed to make your APIs more easily testable (such as useful parameters and return values, using smaller classes or methods, throwing Exceptions, etc.). Describe three test scenarios per team member for a project feature they plan to be responsible for (at least one of which is negative/sad/error producing), the expected outcome, and how your design supports testing for it (such as methods you can call, specific values you can use as parameters and return values to check, specific expected UI displays or changes that could be checked, etc.). A test scenario describes the the expected results from a user's action to initiate a feature in your program (whether "happy" or "sad") and the steps that lead to that result.

There are a few strategies our team discussed to make our code more testable.

1. The first strategy dicussed was to make clear what objects different methods mutated the states of (either directly or indirectly) in the program and also to make clear which object's states those methods relied on. Speaking more concretely, we discussed how passing paremeters into methods from which they can obtain necessary data to do their functionality rather than relying on the object that method is using to have its own references to objects makes for a more testable code base because it makes it easier to ensure that a given method call will lead to a given return value. This also helps our code adhere to the principle of dependency injection.

2. Another strategy to make our code more testable is to think about making sure our code obeys certain properties, instead of just passes certain unit tests. For instance, when I (Alex) write the AI Player, part of my testing will be to test that when I add Alpha-Beta pruning to the search tree that this never changes to result of what move to make, because Alpha-Beta pruning should only make the AI more efficient, and not change its decision. Thinking in terms of these "properties" allows me to more rigorously test to try to ensure the correctness of my code rather than an approach where I just tried to make sure that Alpha-Beta pruning returned the correct value for a few test cases.

